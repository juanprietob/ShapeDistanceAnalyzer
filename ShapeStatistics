#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import ShapeStatistics
import argparse
import sys
import matplotlib.pyplot as plt

def Args():
	parser = argparse.ArgumentParser(description='Shape Statistics')
	parser.add_argument('fileA', metavar='fileA', type=str, 
	                    help='Path for the shape A.')
	parser.add_argument('fileB', metavar='fileB', type=str, 
	                    help='Path for the shape B.')
	parser.add_argument('--bins', action='store', dest='bins',type=int, default=256,
						help='Number of bins to generate the histograms.')
	parser.add_argument('--save', action='store', dest='save_path',type=str,default='',
						help='Path to a CSV file where results will be saved.')
	parser.add_argument('--plot', action='store_true', dest='plot',
						help='Define if plot should be shown.')

	args = parser.parse_args()
	return args

def printStats(stats_dict):
	print('-----------------------------------------------------------------')
	print('Signed distance:\t',stats_dict['signed_distances'])
	print('Corresponding points:\t',stats_dict['corresponding_points_exist'])
	print('Mode:\t',stats_dict['mode'])
	print('Number of bins:\t\t',stats_dict['number_of_bins'])
	print('Minimum:\t\t',stats_dict['minimum'])
	print('Maximum:\t\t',stats_dict['maximum'])
	print('Hausdorf:\t\t',stats_dict['hausdorf'])
	print('mean:\t\t\t', stats_dict['mean'])
	print('sigma:\t\t\t',stats_dict['sigma'])
	print('MSD:\t\t\t',stats_dict['MSD'])
	print('MAD:\t\t\t',stats_dict['MAD'])
	print('Median:\t\t\t',stats_dict['median'])
	print('IQR:\t\t\t',stats_dict['IQR'])
	print('IQR_Q1:\t\t\t',stats_dict['IQR_Q1'])
	print('IQR_Q3:\t\t\t',stats_dict['IQR_Q3'])
	print('-----------------------------------------------------------------')

def main():
	args = Args()

	fileA=args.fileA
	fileB=args.fileB

	valmet=ShapeStatistics.StatisticsLogic()

	valmet.Set('A',fileA)
	valmet.Set('B',fileB)

	bins=args.bins

	stats_list=list()

	#closest point unsigned
	print('#################################################################')
	correspondence=False
	signed=False

	mode='A->B'
	stats_dict0 = valmet.ComputeValues(bins=bins,signed=signed,correspondence=correspondence)

	stats_list.append(stats_dict0['A->B'])
	stats_list.append(stats_dict0['B->A'])
	stats_list.append(stats_dict0['A->B & B->A'])

	printStats(stats_dict0['A->B'])
	printStats(stats_dict0['B->A'])
	printStats(stats_dict0['A->B & B->A'])

	if args.plot:
		plt.figure(1)
		plt.plot(stats_dict0['A->B']['edge_mean'],stats_dict0['A->B']['histogram'],'-*r',label='A->B')
		plt.plot(stats_dict0['B->A']['edge_mean'],stats_dict0['B->A']['histogram'],'-*g',label='B->A')
		plt.plot(stats_dict0['A->B & B->A']['edge_mean'],stats_dict0['A->B & B->A']['histogram'],'-*b',label='A->B and B->A')

		plt.title("Closest point, unsigned distance")
		plt.legend()

	#closest point signed
	print('#################################################################')
	correspondence=False
	signed=True

	stats_dict0 = valmet.ComputeValues(bins=bins,signed=signed,correspondence=correspondence)

	stats_list.append(stats_dict0['A->B'])
	stats_list.append(stats_dict0['B->A'])
	stats_list.append(stats_dict0['A->B & B->A'])

	printStats(stats_dict0['A->B'])
	printStats(stats_dict0['B->A'])
	printStats(stats_dict0['A->B & B->A'])

	if args.plot:
		plt.figure(2)
		plt.plot(stats_dict0['A->B']['edge_mean'],stats_dict0['A->B']['histogram'],'-*r',label='A->B')
		plt.plot(stats_dict0['B->A']['edge_mean'],stats_dict0['B->A']['histogram'],'-*g',label='B->A')
		plt.plot(stats_dict0['A->B & B->A']['edge_mean'],stats_dict0['A->B & B->A']['histogram'],'-*b',label='A->B and B->A')

		plt.title("Closest point, unsigned distance")
		plt.legend()
	#correspondence unsigned
	print('#################################################################')
	correspondence=True
	signed=False

	mode='A<->B'
	stats_dict0 = valmet.ComputeValues(bins=bins,signed=signed,correspondence=correspondence)

	stats_list.append(stats_dict0['A<->B'])

	printStats(stats_dict0['A<->B'])
	if args.plot:
		plt.figure(3)
		plt.plot(stats_dict0['A<->B']['edge_mean'],stats_dict0['A<->B']['histogram'],'-*r')
		plt.title("Correspondence, unsigned distance")

	#correspondence signed
	print('#################################################################')
	correspondence=True
	signed=True

	stats_dict0 = valmet.ComputeValues(bins=bins,signed=signed,correspondence=correspondence)


	stats_list.append(stats_dict0['A->B'])
	stats_list.append(stats_dict0['B->A'])
	stats_list.append(stats_dict0['A->B & B->A'])

	printStats(stats_dict0['A->B'])
	printStats(stats_dict0['B->A'])
	printStats(stats_dict0['A->B & B->A'])

	if args.plot:
		plt.figure(4)
		plt.plot(stats_dict0['A->B']['edge_mean'],stats_dict0['A->B']['histogram'],'-*r',label='A->B')
		plt.plot(stats_dict0['B->A']['edge_mean'],stats_dict0['B->A']['histogram'],'-*g',label='B->A')
		plt.plot(stats_dict0['A->B & B->A']['edge_mean'],stats_dict0['A->B & B->A']['histogram'],'-*b',label='A->B and B->A')

		plt.title("Closest point, unsigned distance")
		plt.legend()

	if args.save_path != '':
		valmet.SaveStatsAsCSV(args.save_path,stats_list)

	'''mu=0
	sig=1
	valmet.test(mu=mu,sig=sig,bins=bins)

	mu=25
	sig=2
	valmet.test(mu=mu,sig=sig,bins=bins)'''


	if args.plot:
		plt.show()

if __name__=='__main__':
	main()

